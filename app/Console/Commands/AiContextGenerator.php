<?php
// app/Console/Commands/AiContextGenerator.php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class AiContextGenerator extends Command
{
    protected $signature = 'ai:context 
                            {--quick : Быстрый режим - только основное}
                            {--full : Полный дамп проекта}
                            {--format=markdown : Формат вывода (markdown/json)}';
    
    protected $description = 'Генерирует контекст проекта для ИИ помощника (полностью автоматический)';

    private $output_lines = [];
    
    // Автоматическое определение структуры проекта
    private $autoDetect = [
        'models' => [
            'pattern' => 'app/Models/*.php',
            'expected' => ['User', 'MasterProfile', 'MassageCategory', 'Service', 'Booking', 'Review', 'Schedule', 'WorkZone', 'PaymentPlan', 'MasterSubscription']
        ],
        'controllers' => [
            'pattern' => 'app/Http/Controllers/*.php',
            'expected' => ['HomeController', 'MasterController', 'FavoriteController', 'CompareController', 'BookingController', 'SearchController', 'ReviewController', 'ProfileController']
        ],
        'migrations' => [
            'pattern' => 'database/migrations/*.php',
            'keywords' => ['users', 'master_profiles', 'massage_categories', 'services', 'bookings', 'reviews', 'schedules', 'work_zones', 'payment_plans']
        ],
        'vue_pages' => [
            'pattern' => 'resources/js/Pages/**/*.vue',
            'expected' => ['Home', 'Masters/Index', 'Masters/Show', 'Profile/Edit', 'Bookings/Create']
        ],
        'vue_components' => [
            'pattern' => 'resources/js/Components/**/*.vue',
            'expected' => ['Masters/MasterCard', 'Booking/BookingForm', 'Booking/Calendar', 'Common/Navbar', 'Common/FilterPanel']
        ]
    ];

    // Паттерны для определения функциональности
    private $functionalityPatterns = [
        'search' => [
            'files' => ['SearchController.php', 'search.vue', 'searchStore.js'],
            'code' => ['function search', 'query =', 'filter', 'Scout::search']
        ],
        'booking' => [
            'files' => ['BookingController.php', 'BookingForm.vue', 'Calendar.vue'],
            'code' => ['store.*booking', 'createBooking', 'available.*slots']
        ],
        'reviews' => [
            'files' => ['ReviewController.php', 'ReviewForm.vue', 'reviews.vue'],
            'code' => ['store.*review', 'rating', 'stars']
        ],
        'payments' => [
            'files' => ['PaymentController.php', 'payment', 'stripe', 'yookassa'],
            'code' => ['payment', 'charge', 'subscription']
        ],
        'notifications' => [
            'files' => ['NotificationController.php', 'mail', 'sms'],
            'code' => ['notify', 'Mail::send', 'SMS::send']
        ]
    ];

    public function handle()
    {
        $this->info('🤖 Автоматическая генерация контекста проекта...');
        
        $mode = $this->option('quick') ? 'quick' : ($this->option('full') ? 'full' : 'normal');
        
        // Собираем контекст
        $this->addHeader();
        $this->addCurrentFocus();
        $this->addAutoDetectedProgress();
        $this->addProjectStructure($mode);
        $this->addRecentChanges();
        $this->addCodeIssues();
        
        if ($mode !== 'quick') {
            $this->addDatabaseAnalysis();
            $this->addRoutesAnalysis();
            $this->addDependenciesCheck();
            $this->addComponentsAnalysis();
        }
        
        if ($mode === 'full') {
            $this->addCodeQualityMetrics();
            $this->addPerformanceAnalysis();
            $this->addSecurityCheck();
        }
        
        $this->addAutoGeneratedNextSteps();
        $this->addFooter();
        
        // Сохраняем
        $this->saveContext();
        $this->showStats();
        
        $this->info('✅ Контекст успешно сгенерирован!');
    }
    
    private function addHeader()
    {
        $this->output_lines[] = "# 🤖 AI Context: SPA Platform - Платформа услуг массажа";
        $this->output_lines[] = "Дата генерации: " . now()->format('Y-m-d H:i:s');
        $this->output_lines[] = "Версия Laravel: " . app()->version();
        $this->output_lines[] = "PHP: " . PHP_VERSION;
        $this->output_lines[] = "";
        $this->output_lines[] = "## 📋 Технический стек";
        $this->output_lines[] = "- Backend: Laravel 12 (PHP 8.2+)";
        $this->output_lines[] = "- Frontend: Vue.js 3 + Inertia.js";
        $this->output_lines[] = "- State: Pinia";
        $this->output_lines[] = "- Стили: Tailwind CSS";
        $this->output_lines[] = "- БД: SQLite";
        $this->output_lines[] = "";
    }
    
    private function addCurrentFocus()
    {
        $this->output_lines[] = "## 🎯 Текущий фокус работы";
        
        // Анализируем последние изменённые файлы
        $recentFiles = $this->getRecentlyModifiedFiles(10);
        
        if (!empty($recentFiles)) {
            $this->output_lines[] = "**Последние изменённые файлы:**";
            foreach ($recentFiles as $file) {
                $time = date('H:i', $file['time']);
                $this->output_lines[] = "- {$file['path']} (изменён в {$time})";
            }
            
            // Определяем над чем работали
            $focus = $this->detectWorkFocus($recentFiles);
            if ($focus) {
                $this->output_lines[] = "";
                $this->output_lines[] = "**Вероятно работали над:** " . $focus;
            }
        }
        
        // Git статус
        if ($this->checkGitExists()) {
            $uncommitted = $this->executeCommand('git status --porcelain');
            if ($uncommitted) {
                $this->output_lines[] = "";
                $this->output_lines[] = "**⚠️ Незакоммиченные изменения:** " . count(explode("\n", trim($uncommitted))) . " файлов";
            }
        }
        
        $this->output_lines[] = "";
    }
    
    private function addAutoDetectedProgress()
    {
        $this->output_lines[] = "## 📊 Автоматический анализ прогресса";
        
        $totalExpected = 0;
        $totalFound = 0;
        $modules = [];
        
        // Анализируем каждый модуль
        foreach ($this->autoDetect as $module => $config) {
            $found = [];
            $missing = [];
            
            if (isset($config['expected'])) {
                foreach ($config['expected'] as $expected) {
                    $pattern = str_replace('*.php', $expected . '.php', $config['pattern']);
                    $exists = !empty(glob(base_path($pattern)));
                    
                    if ($exists) {
                        $found[] = $expected;
                        $totalFound++;
                    } else {
                        $missing[] = $expected;
                    }
                    $totalExpected++;
                }
            } else {
                // Для миграций и других файлов
                $files = glob(base_path($config['pattern']));
                $found = array_map('basename', $files);
                $totalFound += count($found);
                $totalExpected += count($config['keywords'] ?? []);
            }
            
            $moduleProgress = $totalExpected > 0 ? round((count($found) / max(count($found) + count($missing), 1)) * 100) : 0;
            
            $modules[$module] = [
                'name' => $this->getModuleName($module),
                'progress' => $moduleProgress,
                'found' => $found,
                'missing' => $missing
            ];
        }
        
        // Общий прогресс
        $overallProgress = $totalExpected > 0 ? round(($totalFound / $totalExpected) * 100) : 0;
        $this->output_lines[] = "**🎯 Общий прогресс: {$overallProgress}% ({$totalFound}/{$totalExpected} компонентов)**";
        $this->output_lines[] = "";
        
        // Детали по модулям
        foreach ($modules as $key => $module) {
            $bar = $this->createProgressBar($module['progress']);
            $this->output_lines[] = "### {$module['name']} {$bar} {$module['progress']}%";
            
            if (!empty($module['found'])) {
                $this->output_lines[] = "✅ **Готово:** " . implode(', ', array_slice($module['found'], 0, 5));
                if (count($module['found']) > 5) {
                    $this->output_lines[] = "   _и ещё " . (count($module['found']) - 5) . " файлов_";
                }
            }
            
            if (!empty($module['missing'])) {
                $this->output_lines[] = "❌ **Отсутствует:** " . implode(', ', $module['missing']);
            }
            
            $this->output_lines[] = "";
        }
        
        // Анализ функциональности
        $this->output_lines[] = "### 🔧 Функциональность (автоанализ кода)";
        $functionality = $this->analyzeFunctionality();
        
        foreach ($functionality as $feature => $status) {
            $icon = $status['ready'] ? '✅' : ($status['partial'] ? '🔄' : '❌');
            $percent = $status['percentage'];
            $this->output_lines[] = "- {$icon} **{$feature}**: {$percent}% " . ($status['note'] ? "({$status['note']})" : "");
        }
        
        $this->output_lines[] = "";
    }
    
    private function addProjectStructure($mode)
    {
        $this->output_lines[] = "## 📁 Структура проекта";
        
        // Считаем статистику
        $stats = $this->calculateProjectStats();
        
        $this->output_lines[] = "**Статистика:**";
        $this->output_lines[] = "- PHP файлов: {$stats['php']}";
        $this->output_lines[] = "- Vue компонентов: {$stats['vue']}";
        $this->output_lines[] = "- JavaScript: {$stats['js']}";
        $this->output_lines[] = "- Всего строк кода: " . number_format($stats['total_lines']);
        $this->output_lines[] = "";
        
        if ($mode !== 'quick') {
            $this->output_lines[] = "```";
            $this->addSmartDirectoryTree('', 0, $mode === 'full' ? 3 : 2);
            $this->output_lines[] = "```";
        }
        
        $this->output_lines[] = "";
    }
    
    private function addCodeIssues()
    {
        $this->output_lines[] = "## ⚠️ Автоматически найденные проблемы";
        
        $issues = $this->scanForIssues();
        
        if (empty($issues)) {
            $this->output_lines[] = "✅ Проблемы не обнаружены!";
        } else {
            foreach ($issues as $type => $items) {
                $this->output_lines[] = "### {$type} (" . count($items) . ")";
                foreach (array_slice($items, 0, 5) as $item) {
                    $this->output_lines[] = "- {$item['message']} (`{$item['file']}:{$item['line']}`)";
                }
                if (count($items) > 5) {
                    $this->output_lines[] = "_... и ещё " . (count($items) - 5) . "_";
                }
                $this->output_lines[] = "";
            }
        }
        
        $this->output_lines[] = "";
    }
    
    private function addDatabaseAnalysis()
    {
        $this->output_lines[] = "## 🗄️ Анализ базы данных";
        
        // Миграции
        $migrations = glob(database_path('migrations/*.php'));
        $this->output_lines[] = "**Миграций:** " . count($migrations);
        
        // Статус миграций
        try {
            $output = $this->executeCommand('php artisan migrate:status');
            $pending = substr_count($output, 'Pending');
            $ran = substr_count($output, 'Ran');
            
            $this->output_lines[] = "**Статус:** " . ($pending > 0 ? "⚠️ {$pending} не выполнено" : "✅ Все выполнены ({$ran})");
        } catch (\Exception $e) {
            $this->output_lines[] = "**Статус:** Не удалось проверить";
        }
        
        // Анализ таблиц
        try {
            $tables = DB::select("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'");
            $this->output_lines[] = "**Таблиц:** " . count($tables);
            
            // Проверяем наличие данных
            $tablesWithData = 0;
            $totalRecords = 0;
            
            foreach ($tables as $table) {
                try {
                    $count = DB::table($table->name)->count();
                    if ($count > 0) {
                        $tablesWithData++;
                        $totalRecords += $count;
                    }
                } catch (\Exception $e) {
                    // Игнорируем
                }
            }
            
            $this->output_lines[] = "**Данные:** " . ($tablesWithData > 0 ? "{$totalRecords} записей в {$tablesWithData} таблицах" : "База пуста");
            
            // Рекомендации
            if ($totalRecords == 0) {
                $this->output_lines[] = "";
                $this->output_lines[] = "💡 **Рекомендация:** Создайте Seeder для тестовых данных";
            }
        } catch (\Exception $e) {
            $this->output_lines[] = "**Статус БД:** Недоступна";
        }
        
        $this->output_lines[] = "";
    }
    
    private function addRoutesAnalysis()
    {
        $this->output_lines[] = "## 🛣️ Анализ маршрутов";
        
        $routes = $this->analyzeRoutes();
        
        $this->output_lines[] = "**Всего маршрутов:** " . $routes['total'];
        $this->output_lines[] = "**API endpoints:** " . $routes['api'];
        $this->output_lines[] = "**Защищённых:** " . $routes['auth'];
        $this->output_lines[] = "";
        
        // Группировка по контроллерам
        $this->output_lines[] = "**По контроллерам:**";
        foreach ($routes['by_controller'] as $controller => $count) {
            $this->output_lines[] = "- {$controller}: {$count} маршрутов";
        }
        
        $this->output_lines[] = "";
    }
    
    private function addDependenciesCheck()
    {
        $this->output_lines[] = "## 📦 Проверка зависимостей";
        
        // Composer
        if (File::exists(base_path('composer.json'))) {
            $composer = json_decode(File::get(base_path('composer.json')), true);
            $composerLock = File::exists(base_path('composer.lock'));
            
            $this->output_lines[] = "**Composer:** " . ($composerLock ? "✅ Заблокирован" : "⚠️ Запустите composer install");
            
            // Проверяем ключевые пакеты
            $required = ['laravel/framework', 'inertiajs/inertia-laravel', 'laravel/sanctum'];
            $installed = array_keys($composer['require'] ?? []);
            $missing = array_diff($required, $installed);
            
            if (!empty($missing)) {
                $this->output_lines[] = "**Отсутствуют:** " . implode(', ', $missing);
            }
        }
        
        // NPM
        if (File::exists(base_path('package.json'))) {
            $packageLock = File::exists(base_path('package-lock.json'));
            $nodeModules = File::exists(base_path('node_modules'));
            
            $this->output_lines[] = "**NPM:** " . ($packageLock ? "✅ Заблокирован" : "⚠️ Запустите npm install");
            $this->output_lines[] = "**node_modules:** " . ($nodeModules ? "✅ Установлены" : "❌ Отсутствуют");
        }
        
        $this->output_lines[] = "";
    }
    
    private function addComponentsAnalysis()
    {
        $this->output_lines[] = "## 🧩 Анализ компонентов";
        
        // Vue компоненты
        $components = glob(resource_path('js/Components/**/*.vue'));
        $pages = glob(resource_path('js/Pages/**/*.vue'));
        
        $this->output_lines[] = "**Vue компоненты:** " . count($components);
        $this->output_lines[] = "**Vue страницы:** " . count($pages);
        
        // Анализируем использование
        $componentUsage = $this->analyzeComponentUsage();
        
        $this->output_lines[] = "";
        $this->output_lines[] = "**Наиболее используемые:**";
        foreach (array_slice($componentUsage, 0, 5) as $comp => $usage) {
            $this->output_lines[] = "- {$comp}: используется {$usage} раз";
        }
        
        // Неиспользуемые компоненты
        $unused = array_filter($componentUsage, fn($usage) => $usage === 0);
        if (!empty($unused)) {
            $this->output_lines[] = "";
            $this->output_lines[] = "**⚠️ Неиспользуемые компоненты:** " . count($unused);
        }
        
        $this->output_lines[] = "";
    }
    
    private function addCodeQualityMetrics()
    {
        $this->output_lines[] = "## 📈 Метрики качества кода";
        
        $metrics = $this->calculateCodeMetrics();
        
        $this->output_lines[] = "**Средняя длина файла:** " . round($metrics['avg_file_length']) . " строк";
        $this->output_lines[] = "**Самый большой файл:** {$metrics['largest_file']['name']} ({$metrics['largest_file']['lines']} строк)";
        $this->output_lines[] = "**Дублирование кода:** " . ($metrics['duplication'] > 10 ? "⚠️" : "✅") . " {$metrics['duplication']}%";
        $this->output_lines[] = "**Покрытие тестами:** " . ($metrics['test_coverage'] < 50 ? "⚠️" : "✅") . " {$metrics['test_coverage']}%";
        
        // Сложность
        $this->output_lines[] = "";
        $this->output_lines[] = "**Циклическая сложность:**";
        foreach ($metrics['complexity'] as $file => $complexity) {
            if ($complexity > 10) {
                $this->output_lines[] = "- ⚠️ {$file}: {$complexity} (рефакторинг рекомендуется)";
            }
        }
        
        $this->output_lines[] = "";
    }
    
    private function addPerformanceAnalysis()
    {
        $this->output_lines[] = "## ⚡ Анализ производительности";
        
        // Размер assets
        $buildFiles = glob(public_path('build/assets/*'));
        $totalSize = array_sum(array_map('filesize', $buildFiles));
        
        $this->output_lines[] = "**Размер сборки:** " . $this->formatFileSize($totalSize);
        $this->output_lines[] = "**Файлов в сборке:** " . count($buildFiles);
        
        // Проверки оптимизации
        $optimizations = [];
        
        // Проверка сжатия
        $hasGzip = false;
        foreach ($buildFiles as $file) {
            if (str_ends_with($file, '.gz')) {
                $hasGzip = true;
                break;
            }
        }
        
        $optimizations[] = ($hasGzip ? "✅" : "❌") . " Gzip сжатие";
        $optimizations[] = (File::exists(base_path('bootstrap/cache/config.php')) ? "✅" : "❌") . " Config кэш";
        $optimizations[] = (File::exists(base_path('bootstrap/cache/routes-v7.php')) ? "✅" : "❌") . " Route кэш";
        $optimizations[] = (count($buildFiles) > 0 ? "✅" : "❌") . " Production build";
        
        foreach ($optimizations as $opt) {
            $this->output_lines[] = $opt;
        }
        
        $this->output_lines[] = "";
    }
    
    private function addSecurityCheck()
    {
        $this->output_lines[] = "## 🔒 Проверка безопасности";
        
        $issues = [];
        
        // Проверка .env
        if (File::exists(base_path('.env'))) {
            $env = File::get(base_path('.env'));
            
            if (strpos($env, 'APP_DEBUG=true') !== false) {
                $issues[] = "⚠️ APP_DEBUG включен в production";
            }
            
            if (strpos($env, 'APP_KEY=') === false || strpos($env, 'APP_KEY=base64:') === false) {
                $issues[] = "❌ APP_KEY не установлен";
            }
        }
        
        // Проверка прав доступа
        $writableDirs = ['storage', 'bootstrap/cache'];
        foreach ($writableDirs as $dir) {
            if (!is_writable(base_path($dir))) {
                $issues[] = "❌ Директория {$dir} не доступна для записи";
            }
        }
        
        // HTTPS проверка
        if (!File::exists(public_path('.htaccess'))) {
            $issues[] = "⚠️ Отсутствует .htaccess";
        }
        
        if (empty($issues)) {
            $this->output_lines[] = "✅ Критических проблем не обнаружено";
        } else {
            foreach ($issues as $issue) {
                $this->output_lines[] = $issue;
            }
        }
        
        $this->output_lines[] = "";
    }
    
    private function addAutoGeneratedNextSteps()
    {
        $this->output_lines[] = "## 🚀 Рекомендуемые следующие шаги (автоматический анализ)";
        
        $steps = [];
        
        // Анализируем что нужно сделать
        
        // 1. Проверяем отсутствующие файлы
        if (!File::exists(app_path('Models/Schedule.php'))) {
            $steps['high'][] = "Создать модель Schedule для расписания мастеров";
        }
        
        if (!File::exists(app_path('Http/Controllers/ReviewController.php'))) {
            $steps['high'][] = "Создать ReviewController для системы отзывов";
        }
        
        // 2. Проверяем функциональность
        $functionality = $this->analyzeFunctionality();
        
        if ($functionality['search']['percentage'] < 50) {
            $steps['high'][] = "Реализовать поиск мастеров (сейчас {$functionality['search']['percentage']}%)";
        }
        
        if ($functionality['booking']['percentage'] < 30) {
            $steps['critical'][] = "Завершить систему бронирования - ключевая функция!";
        }
        
        // 3. Проверяем БД
        try {
            $usersCount = DB::table('users')->count();
            if ($usersCount == 0) {
                $steps['medium'][] = "Создать Seeder с тестовыми данными";
            }
        } catch (\Exception $e) {
            $steps['critical'][] = "Исправить подключение к базе данных";
        }
        
        // 4. Проверяем компоненты
        if (!File::exists(resource_path('js/Pages/Masters/Show.vue'))) {
            $steps['high'][] = "Создать страницу просмотра профиля мастера";
        }
        
        // 5. Проверяем оптимизацию
        if (!File::exists(public_path('build/manifest.json'))) {
            $steps['medium'][] = "Запустить npm run build для production";
        }
        
        // Выводим по приоритетам
        $priorities = ['critical' => '🔴 Критично', 'high' => '🟡 Важно', 'medium' => '🟢 Желательно'];
        
        foreach ($priorities as $priority => $label) {
            if (!empty($steps[$priority])) {
                $this->output_lines[] = "### {$label}";
                foreach ($steps[$priority] as $i => $step) {
                    $this->output_lines[] = ($i + 1) . ". " . $step;
                }
                $this->output_lines[] = "";
            }
        }
        
        // Прогресс до MVP
        $mvpFeatures = ['models' => 90, 'controllers' => 80, 'frontend' => 70, 'booking' => 30, 'search' => 40];
        $mvpProgress = array_sum($mvpFeatures) / count($mvpFeatures);
        
        $this->output_lines[] = "### 📊 Прогресс до MVP: " . round($mvpProgress) . "%";
        $this->output_lines[] = $this->createProgressBar($mvpProgress) . " Осталось примерно " . $this->estimateTimeToMVP($mvpProgress);
        $this->output_lines[] = "";
    }
    
    private function addFooter()
    {
        $this->output_lines[] = "---";
        $this->output_lines[] = "";
        $this->output_lines[] = "## 📌 Контекст для ИИ помощника";
        $this->output_lines[] = "";
        $this->output_lines[] = "Это автоматически сгенерированный контекст проекта. Все метрики и статусы определены автоматически.";
        $this->output_lines[] = "";
        $this->output_lines[] = "**Проект:** Платформа услуг массажа (аналог Avito для мастеров)";
        $this->output_lines[] = "**Разработчик:** Один человек + ИИ помощник";
        $this->output_lines[] = "**Стек:** Laravel 12 + Vue 3 + Inertia.js";
        $this->output_lines[] = "";
        $this->output_lines[] = "**Принципы работы:**";
        $this->output_lines[] = "1. Предоставляй полный код файлов";
        $this->output_lines[] = "2. Объясняй пошагово для новичка";
        $this->output_lines[] = "3. Учитывай Windows окружение";
        $this->output_lines[] = "4. Фокусируйся на MVP функциональности";
    }
    
    // === ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ===
    
    private function getRecentlyModifiedFiles($limit = 10)
    {
        $files = [];
        $directories = ['app', 'resources/js', 'database'];
        
        foreach ($directories as $dir) {
            $path = base_path($dir);
            if (!File::exists($path)) continue;
            
            $iterator = new \RecursiveIteratorIterator(
                new \RecursiveDirectoryIterator($path)
            );
            
            foreach ($iterator as $file) {
                if ($file->isFile() && !Str::contains($file->getPathname(), ['vendor', 'node_modules'])) {
                    $files[] = [
                        'path' => str_replace(base_path() . DIRECTORY_SEPARATOR, '', $file->getPathname()),
                        'time' => $file->getMTime()
                    ];
                }
            }
        }
        
        // Сортируем по времени изменения
        usort($files, fn($a, $b) => $b['time'] - $a['time']);
        
        return array_slice($files, 0, $limit);
    }
    
    private function detectWorkFocus($recentFiles)
    {
        $areas = [
            'models' => 0,
            'controllers' => 0,
            'migrations' => 0,
            'components' => 0,
            'pages' => 0
        ];
        
        foreach ($recentFiles as $file) {
            if (Str::contains($file['path'], 'Models')) $areas['models']++;
            elseif (Str::contains($file['path'], 'Controllers')) $areas['controllers']++;
            elseif (Str::contains($file['path'], 'migrations')) $areas['migrations']++;
            elseif (Str::contains($file['path'], 'Components')) $areas['components']++;
            elseif (Str::contains($file['path'], 'Pages')) $areas['pages']++;
        }
        
        $maxArea = array_keys($areas, max($areas))[0];
        
        $focusMap = [
            'models' => 'Работа с моделями данных',
            'controllers' => 'Разработка бизнес-логики',
            'migrations' => 'Изменения структуры БД',
            'components' => 'Создание UI компонентов',
            'pages' => 'Разработка страниц'
        ];
        
        return $focusMap[$maxArea] ?? null;
    }
    
    private function analyzeFunctionality()
    {
        $results = [];
        
        foreach ($this->functionalityPatterns as $feature => $patterns) {
            $found = 0;
            $total = count($patterns['files']) + count($patterns['code']);
            $notes = [];
            
            // Проверяем файлы
            foreach ($patterns['files'] as $file) {
                $exists = !empty(glob(base_path("**/{$file}"), GLOB_BRACE));
                if ($exists) $found += 1;
            }
            
            // Проверяем код
            foreach ($patterns['code'] as $codePattern) {
                if ($this->searchInProject($codePattern)) {
                    $found += 0.5; // Код менее важен чем файлы
                }
            }
            
            $percentage = round(($found / $total) * 100);
            
            // Определяем статус
            if ($percentage >= 80) {
                $ready = true;
                $partial = false;
                $note = "готово к использованию";
            } elseif ($percentage >= 30) {
                $ready = false;
                $partial = true;
                $note = "в разработке";
            } else {
                $ready = false;
                $partial = false;
                $note = "не реализовано";
            }
            
            $results[$this->getFeatureName($feature)] = [
                'ready' => $ready,
                'partial' => $partial,
                'percentage' => $percentage,
                'note' => $note
            ];
        }
        
        return $results;
    }
    
    private function calculateProjectStats()
    {
        $stats = [
            'php' => count(glob(base_path('app/**/*.php'), GLOB_BRACE)),
            'vue' => count(glob(resource_path('js/**/*.vue'), GLOB_BRACE)),
            'js' => count(glob(resource_path('js/**/*.js'), GLOB_BRACE)),
            'total_lines' => 0
        ];
        
        // Считаем строки кода
        $files = array_merge(
            glob(base_path('app/**/*.php'), GLOB_BRACE),
            glob(resource_path('js/**/*.{vue,js}'), GLOB_BRACE)
        );
        
        foreach ($files as $file) {
            if (is_file($file)) {
                $stats['total_lines'] += count(file($file));
            }
        }
        
        return $stats;
    }
    
    private function scanForIssues()
    {
        $issues = [];
        $patterns = [
            'TODO' => '/\/\/\s*TODO:?\s*(.+)/i',
            'FIXME' => '/\/\/\s*FIXME:?\s*(.+)/i',
            'Deprecated' => '/@deprecated\s*(.+)/i',
            'Debug' => '/dd\(|dump\(|console\.log\(/i',
            'Security' => '/\$_GET\[|\\$_POST\[|\$_REQUEST\[/'
        ];
        
        $files = array_merge(
            glob(base_path('app/**/*.php'), GLOB_BRACE),
            glob(resource_path('js/**/*.{vue,js}'), GLOB_BRACE)
        );
        
        foreach ($files as $file) {
            if (!is_file($file)) continue;
            
            $content = File::get($file);
            $lines = explode("\n", $content);
            
            foreach ($patterns as $type => $pattern) {
                foreach ($lines as $lineNum => $line) {
                    if (preg_match($pattern, $line, $matches)) {
                        $issues[$type][] = [
                            'file' => str_replace(base_path() . '/', '', $file),
                            'line' => $lineNum + 1,
                            'message' => isset($matches[1]) ? trim($matches[1]) : $type
                        ];
                    }
                }
            }
        }
        
        return $issues;
    }
    
    private function analyzeRoutes()
    {
        $routes = [
            'total' => 0,
            'api' => 0,
            'auth' => 0,
            'by_controller' => []
        ];
        
        if (File::exists(base_path('routes/web.php'))) {
            $content = File::get(base_path('routes/web.php'));
            
            // Считаем маршруты
            preg_match_all('/Route::(get|post|put|patch|delete)\s*\(/', $content, $matches);
            $routes['total'] = count($matches[0]);
            
            // API маршруты
            $routes['api'] = substr_count($content, '/api/');
            
            // Защищённые маршруты
            $routes['auth'] = substr_count($content, 'middleware(\'auth\'') + 
                             substr_count($content, 'middleware([\'auth\'');
            
            // По контроллерам
            preg_match_all('/\[(\w+Controller)::class/', $content, $controllers);
            foreach ($controllers[1] as $controller) {
                $routes['by_controller'][$controller] = 
                    substr_count($content, $controller);
            }
        }
        
        return $routes;
    }
    
    private function analyzeComponentUsage()
    {
        $usage = [];
        $componentFiles = glob(resource_path('js/Components/**/*.vue'), GLOB_BRACE);
        
        foreach ($componentFiles as $file) {
            $componentName = basename($file, '.vue');
            $usage[$componentName] = 0;
            
            // Ищем использование в других файлах
            $searchIn = array_merge(
                glob(resource_path('js/Pages/**/*.vue'), GLOB_BRACE),
                glob(resource_path('js/Components/**/*.vue'), GLOB_BRACE)
            );
            
            foreach ($searchIn as $searchFile) {
                if ($searchFile === $file) continue;
                
                $content = File::get($searchFile);
                if (Str::contains($content, [$componentName, Str::kebab($componentName)])) {
                    $usage[$componentName]++;
                }
            }
        }
        
        arsort($usage);
        return $usage;
    }
    
    private function calculateCodeMetrics()
    {
        $metrics = [
            'avg_file_length' => 0,
            'largest_file' => ['name' => '', 'lines' => 0],
            'duplication' => 0,
            'test_coverage' => 0,
            'complexity' => []
        ];
        
        $files = glob(base_path('app/**/*.php'), GLOB_BRACE);
        $totalLines = 0;
        $fileCount = 0;
        
        foreach ($files as $file) {
            if (!is_file($file)) continue;
            
            $lines = count(file($file));
            $totalLines += $lines;
            $fileCount++;
            
            if ($lines > $metrics['largest_file']['lines']) {
                $metrics['largest_file'] = [
                    'name' => basename($file),
                    'lines' => $lines
                ];
            }
            
            // Простой расчёт цикломатической сложности
            $content = File::get($file);
            $complexity = substr_count($content, 'if (') + 
                         substr_count($content, 'foreach (') + 
                         substr_count($content, 'while (') + 
                         substr_count($content, 'for (') + 
                         substr_count($content, 'case ');
            
            if ($complexity > 10) {
                $metrics['complexity'][basename($file)] = $complexity;
            }
        }
        
        $metrics['avg_file_length'] = $fileCount > 0 ? $totalLines / $fileCount : 0;
        
        // Тестовое покрытие
        $tests = glob(base_path('tests/**/*Test.php'), GLOB_BRACE);
        $metrics['test_coverage'] = round((count($tests) / max(count($files), 1)) * 100);
        
        return $metrics;
    }
    
    private function estimateTimeToMVP($currentProgress)
    {
        $remaining = 100 - $currentProgress;
        
        // Примерная оценка: 1% = 2 часа работы
        $hours = $remaining * 2;
        
        if ($hours < 24) {
            return round($hours) . " часов работы";
        } elseif ($hours < 168) {
            return round($hours / 24) . " дней работы";
        } else {
            return round($hours / 168) . " недель работы";
        }
    }
    
    private function searchInProject($pattern)
    {
        $files = array_merge(
            glob(base_path('app/**/*.php'), GLOB_BRACE),
            glob(resource_path('js/**/*.{vue,js}'), GLOB_BRACE)
        );
        
        foreach ($files as $file) {
            if (!is_file($file)) continue;
            
            $content = File::get($file);
            if (stripos($content, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    private function addSmartDirectoryTree($path, $level, $maxLevel)
    {
        if ($level > $maxLevel) return;
        
        $basePath = base_path($path);
        if (!File::exists($basePath)) return;
        
        $items = scandir($basePath);
        $prefix = str_repeat('│   ', $level);
        
        // Фильтруем и сортируем
        $dirs = [];
        $files = [];
        
        foreach ($items as $item) {
            if (in_array($item, ['.', '..', 'node_modules', 'vendor', '.git', '.idea'])) {
                continue;
            }
            
            $itemPath = $path ? $path . '/' . $item : $item;
            $fullPath = base_path($itemPath);
            
            if (is_dir($fullPath)) {
                // Показываем только важные директории
                if ($this->isImportantDirectory($item, $level)) {
                    $dirs[] = $item;
                }
            } else {
                // Показываем только важные файлы
                if ($this->isImportantFile($item)) {
                    $files[] = $item;
                }
            }
        }
        
        // Выводим директории
        foreach ($dirs as $dir) {
            $itemPath = $path ? $path . '/' . $dir : $dir;
            $fileCount = count(File::allFiles(base_path($itemPath)));
            $this->output_lines[] = $prefix . "├── {$dir}/ ({$fileCount} файлов)";
            
            if ($level < $maxLevel) {
                $this->addSmartDirectoryTree($itemPath, $level + 1, $maxLevel);
            }
        }
        
        // Выводим файлы (только на верхних уровнях)
        if ($level < 2) {
            foreach ($files as $file) {
                $fullPath = base_path($path ? $path . '/' . $file : $file);
                $size = $this->formatFileSize(filesize($fullPath));
                $this->output_lines[] = $prefix . "├── {$file} ({$size})";
            }
        }
    }
    
    private function isImportantDirectory($name, $level)
    {
        $important = ['app', 'database', 'resources', 'routes', 'config', 'public'];
        $subImportant = ['Models', 'Http', 'Controllers', 'js', 'Pages', 'Components', 'migrations'];
        
        if ($level === 0) {
            return in_array($name, $important);
        } else {
            return in_array($name, $subImportant);
        }
    }
    
    private function isImportantFile($filename)
    {
        $extensions = ['php', 'vue', 'js', 'json', 'md'];
        $important = ['composer.json', 'package.json', '.env.example', 'README.md'];
        
        return in_array($filename, $important) || 
               in_array(pathinfo($filename, PATHINFO_EXTENSION), $extensions);
    }
    
    // Остальные вспомогательные методы
    
    private function getModuleName($key)
    {
        $names = [
            'models' => 'Модели данных',
            'controllers' => 'Контроллеры',
            'migrations' => 'Миграции БД',
            'vue_pages' => 'Vue страницы',
            'vue_components' => 'Vue компоненты'
        ];
        
        return $names[$key] ?? $key;
    }
    
    private function getFeatureName($key)
    {
        $names = [
            'search' => 'Поиск мастеров',
            'booking' => 'Система бронирования',
            'reviews' => 'Отзывы и рейтинги',
            'payments' => 'Платежная система',
            'notifications' => 'Уведомления'
        ];
        
        return $names[$key] ?? $key;
    }
    
    private function createProgressBar($percentage)
    {
        $filled = round($percentage / 10);
        $empty = 10 - $filled;
        
        return '[' . str_repeat('█', $filled) . str_repeat('░', $empty) . ']';
    }
    
    private function formatFileSize($bytes)
    {
        if ($bytes < 1024) return $bytes . ' B';
        if ($bytes < 1048576) return round($bytes / 1024, 1) . ' KB';
        return round($bytes / 1048576, 1) . ' MB';
    }
    
    private function checkGitExists()
    {
        return PHP_OS_FAMILY === 'Windows' 
            ? shell_exec('where git 2>nul') !== null
            : shell_exec('which git 2>/dev/null') !== null;
    }
    
    private function executeCommand($command)
    {
        $isWindows = PHP_OS_FAMILY === 'Windows';
        $nullDevice = $isWindows ? '2>nul' : '2>/dev/null';
        
        if (strpos($command, '2>') === false) {
            $command .= ' ' . $nullDevice;
        }
        
        return shell_exec($command);
    }
    
    private function saveContext()
    {
        $dir = storage_path('ai-sessions');
        if (!File::exists($dir)) {
            File::makeDirectory($dir, 0755, true);
        }
        
        $timestamp = now()->format('Y-m-d_H-i-s');
        $filename = "context_{$timestamp}.md";
        $content = implode("\n", $this->output_lines);
        
        File::put($dir . '/' . $filename, $content);
        File::put($dir . '/latest_context.md', $content);
        
        // Сохраняем метаданные
        $metadata = [
            'generated_at' => now()->toIso8601String(),
            'mode' => $this->option('quick') ? 'quick' : ($this->option('full') ? 'full' : 'normal'),
            'stats' => $this->calculateProjectStats(),
            'progress' => $this->calculateOverallProgress()
        ];
        
        File::put($dir . '/latest_meta.json', json_encode($metadata, JSON_PRETTY_PRINT));
        
        $this->info("📄 Контекст сохранён: storage/ai-sessions/{$filename}");
        $this->info("📋 Быстрый доступ: storage/ai-sessions/latest_context.md");
    }
    
    private function calculateOverallProgress()
    {
        // Считаем общий прогресс проекта
        $components = 0;
        $total = 0;
        
        foreach ($this->autoDetect as $module => $config) {
            if (isset($config['expected'])) {
                $total += count($config['expected']);
                foreach ($config['expected'] as $expected) {
                    $pattern = str_replace('*.php', $expected . '.php', $config['pattern']);
                    if (!empty(glob(base_path($pattern)))) {
                        $components++;
                    }
                }
            }
        }
        
        return $total > 0 ? round(($components / $total) * 100) : 0;
    }
    
    private function showStats()
    {
        $this->info("");
        $this->table(
            ['Метрика', 'Значение'],
            [
                ['Строк в отчёте', count($this->output_lines)],
                ['Размер файла', $this->formatFileSize(strlen(implode("\n", $this->output_lines)))],
                ['Время генерации', round(microtime(true) - LARAVEL_START, 2) . ' сек'],
                ['Общий прогресс', $this->calculateOverallProgress() . '%'],
            ]
        );
    }
}